# 从 Prompt 到 Context

## 迈向"模型自主管理上下文"的时代

Context Engineering × Agentic × RLVR

工程收敛为护栏，策略交给模型

---

# 目录

1. **交互模式的演进** - 从单次生成到连续对话
2. **Context 管理的三个阶段** - 静态 → 动态 → 自主式
3. **自主式 Context 的实现** - Agentic 模式与 RLVR
4. **Context Engineering 框架** - 护栏、结构化与策略学习
5. **趋势与展望** - 模型内化与工程简化

---

# 1. 交互模式的演进

从无状态生成到有状态对话

---

## 1.1 简单的生成（续写）

### 特征

- 纯文本输入 → 续写
- 无工具/无外部记忆
- 提示对输出极敏感

---

### 示例对比

```text
# 措辞微调导致输出风格完全不同
prompt_1 = "写一个排序算法"
→ 输出：简单冒泡排序，无注释

prompt_2 = "请实现一个高效的排序算法"
→ 输出：快速排序，带性能分析

prompt_3 = "作为资深工程师，设计一个生产级排序方案"
→ 输出：多算法选择器，完整错误处理
```

Prompt → Output
单向生成，无状态

---

## 1.2 连续对话

### 三角色模型

- **System**: 全局规则与人设
- **User**: 用户输入
- **Assistant**: 模型响应

---

### 状态维护示例

```text
User: 帮我设计一个用户管理系统
Assistant: 好的，我来帮你设计。需要包含用户注册、登录...

User: 加上权限控制
Assistant: 基于前面的设计，我添加RBAC权限模型...

User: 数据库用什么？
Assistant: 考虑到用户管理和权限控制的需求，推荐PostgreSQL...
```

---

### 特性与挑战

- 历史回放 = 短期记忆
- 易受上下文位置影响
- "Lost-in-the-middle" 现象

需要结构化与重排策略

---

# 2. Context 管理的三个阶段

从工程师控制到模型自主管理

---

## 2.1 静态 Context

### 特点

- 一次性拼接所有内容
- 人工设计模板
- 可靠但脆弱

### 适用场景

- 规则清晰
- 领域固定
- 变化较少

---

### 典型结构

```yaml
System Prompt: |
  你是一个专业的助手...

Background: |
  相关背景信息...

Examples: |
  示例1: ...
  示例2: ...

User Query: |
  具体问题...
```

组成部分：System → Background → Examples → Query

---

## 2.2 动态 Context

### 核心能力

- **按需构建**: 根据任务动态选择信息源
- **实时适应**: 随执行状态调整上下文结构
- **增量更新**: 持续整合新获取的信息
- **智能筛选**: 基于相关性过滤冗余内容

---

### 实现模式

- **检索增强**: RAG、向量搜索
- **函数调用**: API集成、工具链
- **状态管理**: 会话记忆、摘要压缩
- **结构化输出**: 证据链、引用追踪

### 信息流程

多样化信息源 → 动态组装 → 结构化Context → 模型推理 → 反馈优化

---

## 2.3 自主式 Context (Agentic Context)

### 核心理念

模型具备Agentic特性，自主决定：

- 何时检索信息
- 写回记忆内容  
- 调用外部工具
- 调整Context结构

### Agentic 特征
- **自主性**: 独立决策，无需人工干预
- **能动性**: 主动探索和策略调整
- **适应性**: 根据任务和环境动态适应

---

# 3. Agentic Context 的技术实现

核心技术栈与算法框架

---

## 3.1 Agentic 循环的核心机制

### Reason-Act-Observe 循环

- **Reason**: 基于当前状态分析和规划
- **Act**: 执行具体动作（检索、工具调用等）
- **Observe**: 观察结果并更新状态

---

### Action 的信息反馈机制

- **检索反馈**: 相关性评分、内容摘要、来源质量
- **工具反馈**: 执行状态、结果数据、错误信息
- **环境反馈**: 系统状态、资源消耗、时间成本
- **用户反馈**: 满意度、澄清需求、偏好调整

---

### 反馈循环的价值

- **信息质量提升**: 基于反馈调整检索策略
- **策略优化**: 学习哪些Action在何时有效
- **错误恢复**: 检测到问题时的补救措施
- **成本控制**: 平衡信息获取与资源消耗

---

## 3.2 Self-RAG 与 Memory Management

### Self-RAG 机制

- **自判断检索需求**: 模型决定是否需要外部信息
- **动态检索策略**: 根据问题类型选择检索方式
- **检索结果评估**: 判断获取信息的相关性和质量
- **迭代优化**: 基于结果调整检索策略

---

### Memory Management

- **分层存储**: 短期工作记忆 vs 长期知识记忆
- **智能压缩**: 保留关键信息，丢弃冗余内容
- **按需读写**: 根据任务需要动态管理记忆内容
- **遗忘机制**: 清理过时或不准确的信息

---

## 3.3 基于可验证奖励的强化学习 (RLVR)

### 核心概念

RLVR = Reinforcement Learning with Verifiable Rewards
- 使用确定性的二元奖励信号（正确/错误）
- 避免传统RLHF中奖励模型的主观性偏差
- 特别适用于有明确正确答案的任务

### 可验证奖励的优势

- **无偏差**: 基于客观标准，非人工偏好
- **防篡改**: 难以通过"奖励黑客"绕过
- **精确性**: 直接连接到ground truth

---

### 在Context管理中的应用

- **检索质量验证**: 检索结果是否包含正确信息
- **推理路径验证**: 逻辑链条是否完整有效
- **工具调用验证**: API调用结果是否符合预期
- **整体任务验证**: 最终输出是否达成目标

### 局限性认知

- 可能缩窄模型探索空间，偏向已知高奖励路径
- 需要与多样性保持平衡

---

## 3.4 渐进式自主权让渡

### 分阶段让渡策略

**第一阶段 - 监督决策**:
- 人工定义所有Context管理规则
- 模型按规则执行，记录决策数据
- 建立基础的状态-动作映射

**第二阶段 - 辅助决策**:
- 模型提出Context管理建议
- 人工审核并选择最终决策
- 收集人工偏好数据用于训练

---

### 第三阶段 - 约束自主

**可信边界内自主**:
- 在安全边界内给予完全自主权
- 超出边界时自动寻求人工干预
- 持续扩大可信边界范围

**验证与回退机制**:
- 实时验证决策质量
- 异常时自动回退到更保守策略
- 维持系统可靠性底线

---

### RLVR训练的奖励设计

**多维度奖励函数**:
```python
R_total = α·R_task + β·R_efficiency + γ·R_safety + δ·R_user
# R_task: 任务完成质量 (准确性、完整性)
# R_efficiency: 资源效率 (时间、token、API调用)  
# R_safety: 安全性 (是否违反约束、异常处理)
# R_user: 用户满意度 (反馈评分、交互体验)
```

**稀疏奖励与密集反馈结合**:
- 任务完成时给予稀疏奖励
- 过程中提供密集的中间反馈
- 通过验证器提供实时质量评估

---

# 4. Context Engineering 工程框架

从技术实现到生产实践

---

## 4.1 系统架构设计

### 分层架构
- **接口层**: 用户交互与任务输入
- **编排层**: Agentic决策与工作流控制  
- **执行层**: 具体的检索、推理、工具调用
- **存储层**: Context状态与记忆管理

### 模块化设计
- **可插拔组件**: 不同技术栈的灵活替换
- **标准接口**: 统一的输入输出协议
- **可观测性**: 完整的执行轨迹跟踪

---

## 4.2 工程实践考虑

### 性能与可靠性
- **延迟优化**: Agentic决策的响应时间控制
- **容错机制**: 异常情况的优雅降级
- **资源管理**: 计算和存储资源的高效利用

### 安全与控制
- **权限边界**: Agentic行为的安全约束
- **审计追踪**: 决策过程的完整记录
- **人工干预**: 关键决策的人工确认机制

---

## 4.3 评估与优化

### 评测体系
- **任务完成度**: 目标达成的准确性
- **效率指标**: 资源消耗与时间成本
- **用户体验**: 交互质量与满意度

### 持续改进
- **A/B测试**: 不同策略的对比验证
- **反馈循环**: 用户反馈的快速迭代
- **版本管理**: Context策略的版本控制

---

## 4.4 生产部署挑战

### 技术挑战
- **扩展性**: 大规模并发的处理能力
- **一致性**: 分布式环境下的状态同步
- **监控**: 复杂系统的实时监控

### 业务挑战  
- **成本控制**: Agentic行为的经济效益平衡
- **合规要求**: 行业规范与法律法规适配
- **团队协作**: 跨领域团队的协作机制

---

# 5. 趋势与展望

从外部工程到内在能力

---

## 5.1 所有逻辑和经验会被内化

### 内化机制

- **记忆蒸馏**: 片段→概念
- **技能固化**: 经验→能力
- **策略学习**: 规则→直觉

---

### 技术路径

- 潜在思维（Private CoT）
- 端到端行为微调
- 持续学习与适应

---

### 经验层次

片段 → 摘要 → 概念 → 策略 → 模型内化

从外部规则到内在能力的转化

---

## 5.2 语言是工具，编程语言也是工具

### 统一接口观

- 自然语言 = 交互接口
- DSL = 领域接口
- 编程语言 = 执行接口

---

### 模型选择策略

根据任务选择"工具语"：

- 理解任务 → 自然语言
- 精确表达 → DSL
- 执行操作 → 代码

---

### 多工具统一流程

任务 → 模型 → 选择(自然语言/DSL/代码) → MCP协议 → 统一执行

所有"语言"归一为可调用接口

---

## 5.3 提供"在领域内找到答案的能力"

### 优化目标转变

- ❌ 追求单题最优解
- ✅ 追求流程最优化

---

### 探索-验证-整合流程

搜索空间/探索策略 → 证据收集 → 验证逻辑 → 结论生成 → 知识整合

---

# References

### Context Engineering
- **A Survey of Context Engineering for Large Language Models**
  https://arxiv.org/abs/2507.13334

---

### Memory Management
- **A-Mem: Agentic Memory for LLM Agents**
  https://arxiv.org/pdf/2502.12110
- **H-MEM: Hierarchical Memory for High-Efficiency Long-Term Reasoning in LLM Agents**
  https://arxiv.org/pdf/2507.22925

---

### Agentic Benchmarks
- **BrowseComp: A Simple Yet Challenging Benchmark for Browsing Agents**
  https://arxiv.org/pdf/2504.12516

---

# 谢谢

从 Prompt Engineering 到 Context Engineering
让模型成为自主的智能体

Q & A

---

# 相关图片展示

<div class="grid grid-cols-2 gap-4">

<img src="./assets/微信图片_20250919102930_29_14.jpg" class="w-full h-auto" />

<img src="./assets/微信图片_20250919102931_30_14.jpg" class="w-full h-auto" />

<img src="./assets/微信图片_20250919102932_31_14.jpg" class="w-full h-auto" />

<img src="./assets/微信图片_20250919102933_32_14.jpg" class="w-full h-auto" />

<img src="./assets/微信图片_20250919102935_33_14.jpg" class="w-full h-auto" />

<img src="./assets/微信图片_20250919102936_34_14.jpg" class="w-full h-auto" />

</div>
